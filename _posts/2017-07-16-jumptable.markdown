---
author: wulei
comments: true
date: 2017-07-16 04:54:03+00:00
link: http://wulei.kim/2017/07/16/jumptable/
slug: jumptable
title: 跳跃表，基于链表的高性能查找的数据结构
wordpress_id: 70
categories:
- 数据结构
tags:
- 数据结构
- 跳跃表
- 链表
---

假设有一个游戏内的商品交易系统，可以按照不同的装备属性字段排序，还要支持按照商品名的精确查询和没有商品名的全量查询。商品数据库里共有几十万条记录，应该怎样实现商品的快速查找呢？

要支持商品的全量查询，就不能直接使用数据库查询。只有提前在内存中存储不同排序的全量商品集合，在每次请求查询的时候返回对应的集合。

假如没有Redis这样的内存数据库，我们需要自己用合适的数据结构来实现。对于商品集合这样的线性关系，我们可以一下想到使用线性表或者链表的方式来实现。如果使用线性表，对于有序集合的查找可以使用二分查找来快速的找到对应的商品，但是对于商品的插入和删除存在较大的性能问题，在第k个位置插入一条记录，需要后(n-k)个记录全部往后移动，这样的复杂度为O(n)。对于链表，虽然商品的插入和删除非常容易，只需要改变指针的指向，但查找操作就非常麻烦，需要从第一条记录开始逐条查找，复杂度也为O(n)。

**如果我们将有序链表的关键节点提取出来，实现一层类似索引结构的新的链表，那么复杂度将大大降低。这就是跳跃表。**

**![](http://wulei.kim/wp-content/uploads/2017/07/img_0332-1024x768.png)**

对于跳跃表，当我们要查找的时候，只需要先在索引链表中查找，查找到对应的区间后再在原链表中查询。

如一个链表为1->2->3->4->5->6->7->...，我们可以将其中的奇数结点提取出来作为关键节点，则第一级索引为1->3->5->7->...,在几十万记录的数据中，只有一级索引肯定是不够的，那么可以将第一级索引再提取出关键结点，形成第二级索引，如果我们将最高级索引提取到只有几个元素，可以发现查找过程和线性表的二分查找非常类似。只是这样会增加空间复杂度，典型的空间换时间，当然我们更倾向于时间复杂度的优化。

![](http://wulei.kim/wp-content/uploads/2017/07/img_0333-1024x768.png)

那么跳跃表的插入操作是怎样的呢？

1.先找到原链表的对应位置并将其插入。

_（对于一个结点是否向上提取成为关键结点，我们采取一种“抛硬币”的方式，即每一个结点有50%的几率可以向上成为关键结点，这样做虽然不能保证关键结点的完全均匀分布，但可以保证关键节点大致区域均匀。采用“抛硬币”的方式的原因是因为跳跃表结点的插入删除具有随机性，很难找到一种算法使关键结点的分布完全均匀。）_

2.使用“抛硬币”的方式决定这个结点是否成为关键节点。如果成为关键结点，则将其插入这一级索引链表，并继续使用这个方法判断是否成为上一级索引的结点。

跳跃表的删除操作：

1.从最上面一级索引链表开始查找。

2.如果在当前一级链表中没有找到，则在对应区间的下一级链表查找，直到查找到该结点。

3.如果在当前一级链表中找到了该结点，则删除这一级的该结点并向下删除所有该结点。

4.需要注意的是：如果这一级删除该节点后只剩下一个结点，则删除这一级，因为一个结点没有任何意义。

![](http://wulei.kim/wp-content/uploads/2017/07/img_0331-1024x768.png)

_这种数据结构和二叉平衡树(AVL)的区别在于：跳跃表维持结构平衡的成本较低，而AVL树维持结构平衡的成本较高。_

_Redis中的Sorted-set集合就是对跳跃表的改进和应用。_
