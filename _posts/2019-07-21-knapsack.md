---
author: wulei
comments: true
date: 2019-07-21 13:03:00+00:00
slug: knapsack
title: 背包问题的部分解题方法
tags:
- 背包问题
- 动态规划
- 深度优先搜索
---
背包问题可以描述为，给定一组物品，每个物品有自己的重量和价值，如何再有限的重量内，如何选择物品使物品的总价值最高。
背包问题也具有多种形式，如果可以拿走物品的部分，则可以使用贪心算法，每次优先选择单位重量价值最高的物品（价值/物品）。如果问题中物品只能选择不拿或者全部拿走的话，称为0-1背包问题。0-1背包问题有多种解法，如暴力枚举法，回溯法，动态规划和分支限界法。本文主要总结了回溯法和动态规划。
### 回溯法
#### 问题描述
*问题来源：小米OJ 第24题*
> 一箱失落多年的宝藏被两位海盗找到，宝箱里的一堆大小与重量各不相同的金块。 他们称出了每个金块的重量，但是如何如何平分这些金子却令他们十分头疼。 程序员们，你能告诉两位海盗，他们能否平分这箱宝藏么？
假设宝箱里有三块金子，重量分别为：1,2,3。则他们可以平分这些金子：1+2=3 又假设宝箱里有四块金子，重量分别为：1,2,6,4。则他们无法找到平分的方法。

问题可以一般化为：给定一个整数数组，是否可以将数组划分为两个不相交的子集，使得这两个子集的和相等。
这个问题可以转化为0-1背包问题，使用回溯法可以解决这类问题。回溯法的思想是在解空间内，使用DFS的思想搜索解空间，直到找到符合条件的路径。实现的方法可以使用递归回溯，也可以借助栈的LIFO的特点，实现非递归的回溯。
#### 递归的回溯实现
``` python
def findNum(nums, i, n):
    if n == 0:
        return True
    elif n < 0:
        return False
    else:
        result = False
        for j in range(i, len(nums) - 1):
            result = result or findNum(nums, j + 1, n - nums[j])
        return result

line = input().strip()
line = list(map(int, line.split(',')))
s = sum(line)
if s % 2 == 1:
    print('false')
else:
    target = int(s / 2)
    print('true' if findNum(line, 0, target) else 'false')
```
要将数组划分为两个和相等的子数组，则数组的和必然是偶数，所以先判断数组的和。然后问题转变为在数组中寻找和为二分之一数组和的子数组。
### 动态规划
动态规划适用于有最优子结构的问题，问题的最优解来源于子问题的最优解，背包问题则是动态规划的经典问题。使用动态规划有三点需要做，第一是分析最优子结构，第二是明确边界，第三是寻找递推式（或者叫状态转换方程）。
#### 问题描述
*问题来源：小米OJ 第27题*
> 石头收藏家小明在徒步登山的时候发现了一堆美丽的石头。这些石头价值不菲，但是都很重，小明自身的力气有限，一次只能拿他拿得动的一部分。每块石头的重量不同，价值也不同。问小明在力所能及的情况下能拿走价值多少的石头。
说明：小明只能搬运一次。
例如：小明只能拿得动 10 kg，每块石头的重量分别为2kg，3kg，5kg，7kg，对应的价值分别为 1万，5万，2万，4万。小明能拿的是 3kg 以及 7kg 的石头，价值 9 万。
输入：
单组输入，每组输入分 3 行：
第 1 行是一个整数，表示小明一次能搬运的最大重量。
第 2 行是一组数，表示每块石头的重量。
第 3 行是一组数，表示每块石头的对应的价值。
石头总数不大于 60.

#### 问题分析
为了方便分析，将该问题一般化为：设有$n$件物品,每件物品的价值记为$P_i$，每件物品的体积记为$V_i$，用一个最大容量为$V_{max}$的背包，求装入物品的最大值。则子问题$F(i,v)$表示取第$i$件商品放入体积为$v$的背包中的最大价值，那么问题的最终解显然就是$F(n, V_{max})$。
当$i=0$时，显然此时子问题的解为0，当考虑第$i$件物品时，如果物品的体积大于背包的体积，那么这件物品肯定不会放入，则此时$F(i,v)=F(i-1,v)$，如果物品体积小于背包的体积，那么此时如果第$i$件物品不放入，则$F(i,v)=F(i-1,v)$，如果放入这件物品，则$F(i,v)=F(i-1,v-V_i)+P_i$。那么这个子问题的解这件物品放与不放的价值的最大值。所以0-1背包问题的状态转移方程为：
$$F(i,v) = 
\begin{cases}
0,i=0\\
F(i-1,v),v<V_i\\
max[F(i-1,v),F(i-1,v-V_i)+P_i],v\geq V_i
\end{cases}$$
#### 实现
通过递推式可以轻易的使用二维数组来存储递推过程，这样时间复杂度和空间复杂度都是$O(nV_{max})$，但是空间复杂度上还可以优化，因为对于每一件物品的递推，结果只与上一件物品相关，也就是之和二维数组的上一行有关系，那么就可以使用一个一维数组。这种问题中成为滚动数组。需要注意的是，使用滚动数组时，需要从后往前进行递推，这样才不会使影响到后面的结果。
``` python
max_weight, weight, value = input().strip(), input().strip(), input().strip()
max_weight, weight, value = int(max_weight), list(map(int, weight.split(' '))), list(map(int, value.split(' ')))

dp = [0] * (max_weight + 1)

for i in range(len(weight)):
    j = max_weight
    while j >= weight[i]:
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
        j -= 1
print(dp[max_weight])
```